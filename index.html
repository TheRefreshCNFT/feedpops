<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Feed Me v1</title>
  <style>
    :root{
      --bg0:#0A0D16;                 /* slightly softer */
      --bg1:#0F1930;                 /* slightly softer */
      --card: rgba(255,255,255,0.075);
      --card2: rgba(255,255,255,0.095);
      --stroke: rgba(255,255,255,0.11);
      --stroke2: rgba(255,255,255,0.16);
      --text:#E7EEFF;
      --muted:#B4C0DD;
      --accent:#6DE8CF;              /* slightly less neon */
      --accent2:#7D9CFF;
      --warn:#FF7180;
      --ok:#74F59D;
      --tryText:#FFB44A;
      --shadow: 0 18px 55px rgba(0,0,0,0.45);
      --radius: 18px;
      --radius2: 14px;
      --pad: 14px;
      --gap: 12px;
      --tap: 48px;
      --maxw: 1080px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      color:var(--text);
      font-family:var(--sans);
      -webkit-font-smoothing: antialiased;
      background:
radial-gradient(1200px 900px at 15% 10%, rgba(138,167,255,0.14), transparent 55%),
radial-gradient(1000px 800px at 85% 15%, rgba(109,232,207,0.12), transparent 55%),
radial-gradient(900px 700px at 35% 95%, rgba(255,113,128,0.08), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow-x:hidden;
    }

    .wrap{
      width: min(var(--maxw), calc(100% - 22px));
      margin: 18px auto 40px;
      display:flex;
      flex-direction:column;
      gap: 14px;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      overflow:hidden;
    }
    .cardInner{ padding: 18px; }
    .headerCard .cardInner{
      padding: 18px 18px 16px;
      text-align:center;
    }
    h1{
      margin:0;
      font-size: 28px;
      letter-spacing: 0.3px;
      line-height: 1.15;
    }
    .subtitle{
      margin-top: 8px;
      color: var(--muted);
      font-size: 15px;
    }

    .primary{
      position:relative;
    }

    /* Tabs */
    .tabs{
      display:flex;
      gap: 8px;
      padding: 12px 12px 0;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
    }
    .tabBtn{
      height: var(--tap);
      min-width: max-content;
      padding: 0 14px;
      border-radius: 999px;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      font-weight: 650;
      letter-spacing: 0.2px;
      cursor:pointer;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      touch-action: manipulation;
    }
    .tabBtn:active{ transform: scale(0.98); }
    .tabBtn[aria-selected="true"]{
      background: linear-gradient(180deg, rgba(124,242,214,0.18), rgba(138,167,255,0.10));
      border-color: rgba(124,242,214,0.35);
    }

    .panel{
      padding: 12px;
    }

    .panelTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .panelTitle{
      font-size: 14px;
      color: var(--muted);
      letter-spacing: 0.15px;
    }
    .actions{ display:flex; gap: 10px; align-items:center; }

    .btn{
      height: var(--tap);
      padding: 0 14px;
      border-radius: 14px;
      border: 1px solid var(--stroke2);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      font-weight: 700;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap: 10px;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      touch-action: manipulation;
      user-select:none;
      white-space:nowrap;
    }
    .btn:active{ transform: scale(0.985); }
    .btn.primary{
      border-color: rgba(124,242,214,0.36);
      background: linear-gradient(180deg, rgba(124,242,214,0.16), rgba(124,242,214,0.08));
    }
    .btn.danger{
      border-color: rgba(255,107,122,0.35);
      background: linear-gradient(180deg, rgba(255,107,122,0.16), rgba(255,107,122,0.07));
    }
    .btn.ghost{
      background: rgba(255,255,255,0.03);
      border-color: var(--stroke);
    }
    .iconBtn{
  width: 44px;
  height: 44px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.05);
  color: var(--text);
  cursor: pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight: 900;
  user-select:none;
  touch-action: manipulation;
}
.iconBtn:active{ transform: scale(0.98); }
.iconBtn.danger{
  border-color: rgba(255,107,122,0.35);
  background: rgba(255,107,122,0.10);
}

    .chip{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(234,240,255,0.85);
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.04);
      border-radius: 999px;
      padding: 6px 10px;
      white-space:nowrap;
    }

    /* My Foods table */
    .subCard{
      background: var(--card2);
      border: 1px solid var(--stroke);
      border-radius: var(--radius2);
      overflow:hidden;
    }
    .subHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--stroke);
      gap: 10px;
    }
    .subHead h3{
      margin:0;
      font-size: 15px;
      letter-spacing: 0.2px;
    }
    .scrollBox{
      max-height: 360px; /* ‚Äúreasonable amount‚Äù then scroll */
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }

    table{
      width:100%;
      border-collapse: collapse;
      font-size: 14px;
      min-width: 740px; /* allows horizontal scroll on small screens */
    }
    .tableWrap{
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    th, td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      vertical-align: top;
    }
    th{
      position: sticky;
      top: 0;
      background: rgba(12,16,28,0.92);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: rgba(170,182,214,0.95);
      border-bottom: 1px solid rgba(255,255,255,0.10);
      z-index: 2;
    }
    td small{ color: var(--muted); }
    .badgeYes{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: 22px;
      min-width: 46px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid rgba(116,245,157,0.25);
      background: rgba(116,245,157,0.10);
      color: rgba(208,255,226,0.92);
      font-weight: 800;
      font-size: 12px;
    }
    .badgeNo{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: 22px;
      min-width: 46px;
      padding: 0 10px;
      border-radius: 999px;
      border: 1px solid rgba(170,182,214,0.18);
      background: rgba(255,255,255,0.04);
      color: rgba(170,182,214,0.95);
      font-weight: 800;
      font-size: 12px;
    }

    .cellInput, .cellNotes{
  width: 100%;
  min-height: 40px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.05);
  color: var(--text);
  padding: 10px 10px;
  font-size: 14px;
  outline: none;
}
.cellNotes{ min-height: 44px; resize: vertical; }

.cellChk{
  display:flex;
  align-items:center;
  justify-content:center;
  gap: 8px;
  min-height: 40px;
}
.cellChk input{
  width: 18px;
  height: 18px;
}


    /* Cards grid for recipes/lists */
    .cards{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 740px){
      .cards{
        grid-template-columns: 1fr 1fr;
      }
    }
    @media (min-width: 1020px){
      .cards{
        grid-template-columns: 1fr 1fr 1fr;
      }
    }

    .miniCard{
      border-radius: var(--radius2);
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,0.05);
      padding: 12px;
      cursor:pointer;
      touch-action: manipulation;
      user-select:none;
      transition: transform .08s ease, border-color .2s ease, background .2s ease;
      min-height: 120px;
      display:flex;
      flex-direction:column;
      gap: 8px;
    }
    .miniCard:active{ transform: scale(0.99); }
    .miniCard:hover{ border-color: rgba(124,242,214,0.20); }
    .miniTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 10px;
    }
    .miniTitle{
      margin:0;
      font-size: 15px;
      line-height: 1.25;
      letter-spacing: 0.2px;
    }
    .miniMeta{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .miniBody{
      color: rgba(234,240,255,0.9);
      font-size: 13px;
      line-height: 1.35;
      overflow:auto;
      max-height: 130px; /* partial view */
      padding-right: 4px;
    }
    .miniBody .muted{ color: var(--muted); }

    /* Modals */
    .modalOverlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 16px;
      z-index: 9999;
    }
    .modalOverlay.show{ display:flex; }
    .modal{
      width: min(980px, 100%);
      max-height: min(86vh, 760px);
      overflow:hidden;
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(12,16,28,0.88);
      box-shadow: 0 25px 80px rgba(0,0,0,0.6);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      display:flex;
      flex-direction:column;
    }
    .modalHead{
      padding: 14px 14px 12px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .modalHead h2{
      margin:0;
      font-size: 16px;
      letter-spacing: 0.2px;
    }
    .modalBody{
      padding: 14px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .modalFoot{
      padding: 12px 14px 14px;
      border-top: 1px solid rgba(255,255,255,0.10);
      display:flex;
      gap: 10px;
      justify-content:flex-end;
      flex-wrap:wrap;
    }

    .grid5{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }
    @media (min-width: 860px){
      .grid5{
        grid-template-columns: 1.15fr 0.7fr 0.9fr 0.9fr 1.3fr;
        align-items:start;
      }
    }

    .field{
      display:flex;
      flex-direction:column;
      gap: 6px;
      min-width: 0;
    }
    label{
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(170,182,214,0.95);
    }
    input[type="text"], input[type="number"], textarea, select{
      width:100%;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      padding: 12px 12px;
      outline:none;
      font-size: 14px;
      min-height: 44px;
    }
    textarea{ min-height: 96px; resize: vertical; }
    input::placeholder, textarea::placeholder{ color: rgba(170,182,214,0.55); }

    .row{
      display:flex;
      align-items:center;
      gap: 10px;
      flex-wrap:wrap;
    }
    .inline{
      display:flex;
      align-items:center;
      gap: 10px;
      min-height: 44px;
    }
    .chk{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      user-select:none;
    }
    .chk input{ width: 18px; height: 18px; }

    .hint{
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
      margin-top: 2px;
    }

    /* Grocery list items editor */
    .listItems{
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .listRow{
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
      border-radius: 16px;
      padding: 12px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    @media (min-width: 900px){
      .listRow{
        grid-template-columns: 1.3fr 0.7fr 0.9fr 1.3fr;
        align-items:start;
      }
    }
    .listRowActions{
      display:flex;
      justify-content:flex-end;
      gap: 8px;
      margin-top: 2px;
    }

    .hr{
      height:1px;
      background: rgba(255,255,255,0.10);
      margin: 10px 0;
    }

    .empty{
      padding: 12px;
      border: 1px dashed rgba(255,255,255,0.18);
      border-radius: 16px;
      color: var(--muted);
      background: rgba(255,255,255,0.03);
    }

    .srOnly{
      position:absolute;
      width:1px; height:1px;
      padding:0; margin:-1px;
      overflow:hidden; clip:rect(0,0,0,0);
      white-space:nowrap; border:0;
    }

/* Grocery pref coloring (derived from My Foods) */
/* overrides base input color */
input.gNameLike{ color: var(--ok) !important; font-weight: 850; }
input.gNameTry{ color: var(--tryText) !important; font-weight: 850; }
/* My Foods: "GL" button */
.glMiniBtn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  margin-left: 8px;
  padding: 0 10px;
  height: 28px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.05);
  color: rgba(234,240,255,0.95);
  font-weight: 900;
  cursor:pointer;
  user-select:none;
  touch-action: manipulation;
  letter-spacing: .02em;
}
    /* Multi-add session: replace GL with a checkbox */
.glPickLabel{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  margin-left: 8px;
  width: 34px;
  height: 28px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.04);
  cursor: pointer;
  user-select:none;
  touch-action: manipulation;
}
.glPickLabel input{
  width: 18px;
  height: 18px;
}

/* Pinned floating bar */
.glPickBar{
  position: fixed;
  left: 50%;
  bottom: 14px;
  transform: translateX(-50%);
  width: min(var(--maxw), calc(100% - 22px));
  z-index: 9998;
  display:none;
}
.glPickBar.show{ display:block; }

.glPickBarInner{
  border-radius: 18px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(12,16,28,0.78);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 18px 55px rgba(0,0,0,0.48);
  padding: 12px;
  display:flex;
  gap: 12px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}
.glPickMeta{ display:flex; flex-direction:column; gap:2px; }

.glMiniBtn:active{ transform: scale(0.98); }

/* Grocery viewer "done" line */
.glDone{
  text-decoration: line-through;
  opacity: 0.65;
}


/* Small inline "check notes" star */
.noteStarBtn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  margin-left: 8px;
  width: 22px;
  height: 22px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.05);
  color: var(--tryText);
  font-weight: 900;
  text-shadow: 0 0 10px rgba(255,180,74,0.25);
  cursor: pointer;
  user-select:none;
  touch-action: manipulation;
}
.noteStarBtn:active{ transform: scale(0.98); }

/* Grocery list editor layout:
   Mobile: ITEM/QTY/UNIT on top; NOTES + DESCRIPTION side-by-side; buttons underneath */
@media (max-width: 899px){
  .listRow{
    grid-template-columns: 1fr 1fr 0.85fr 0.95fr;
    grid-template-areas:
      "item item qty unit"
      "notes notes desc desc"
      "actions actions actions actions";
    align-items:start;
  }
  .listRow .field[data-area="item"]{ grid-area: item; }
  .listRow .field[data-area="qty"]{ grid-area: qty; }
  .listRow .field[data-area="unit"]{ grid-area: unit; }
  .listRow .field[data-area="notes"]{ grid-area: notes; }
  .listRow .field[data-area="desc"]{ grid-area: desc; }

  .listRowActions{
    grid-area: actions !important;
    margin-top: 6px;
    justify-content:flex-end;
  }
}

/* Desktop: 5 columns now that Description exists */
@media (min-width: 900px){
  .listRow{
    grid-template-columns: 1.2fr 0.55fr 0.75fr 1fr 1fr;
  }
}

  </style>
</head>

<body>
  <div class="wrap">
    <div class="card headerCard">
      <div class="cardInner">
        <h1>Feed Me</h1>
        <div class="subtitle">I'm so Hungry</div>
      </div>
    </div>

    <div class="card primary">
      <div class="tabs" role="tablist" aria-label="Feed Me Tabs" id="tabs"></div>
      <div class="panel" id="panel"></div>
    </div>

    <div class="card">
      <div class="cardInner" style="display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:space-between;">
        <div style="display:flex;flex-direction:column;gap:4px;min-width:220px;">
          <div style="font-weight:800;letter-spacing:0.2px;">Storage</div>
          <div class="subtitle" style="margin:0;">Saves locally by default (localStorage).</div>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <span class="chip" id="statFoods">Foods: 0</span>
          <span class="chip" id="statRecipes">Recipes: 0</span>
          <span class="chip" id="statLists">Grocery Lists: 0</span>
          <button class="btn danger" id="btnReset" type="button" title="Clears all local data">Reset Local Data</button>
          <button class="btn ghost" id="btnExport" type="button" title="Download a JSON backup">Export JSON</button>
          <button class="btn ghost" id="btnImport" type="button" title="Import a JSON backup">Import JSON</button>
          <input class="srOnly" id="importFile" type="file" accept="application/json,.json" />

        </div>
      </div>
    </div>
  </div>

    <!-- Pinned bar for Grocery List multi-select -->
  <div id="glPickBar" class="glPickBar" aria-hidden="true">
    <div class="glPickBarInner">
      <div class="glPickMeta">
        <div style="font-weight:900;">Multi-add</div>
        <div class="subtitle" style="margin:0;font-size:12px;">
          Selected: <span id="glPickCount" style="font-family:var(--mono);font-weight:900;">0</span>
        </div>
      </div>
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end;">
        <button class="btn primary" id="glPickAddBtn" type="button">Add Selected</button>
        <button class="btn ghost" id="glPickCancelBtn" type="button">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Modal Host -->
  <div class="modalOverlay" id="modalOverlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHead">
        <h2 id="modalTitle">Modal</h2>
      </div>
      <div class="modalBody" id="modalBody"></div>
      <div class="modalFoot" id="modalFoot"></div>
    </div>
  </div>

  <!-- datalist for autofill -->
  <datalist id="foodsDatalist"></datalist>

  <script>
    /*****************************************************************
     * Feed Me ‚Äî Mobile-first single-file app
     * Default persistence: localStorage
     * Optional PHP persistence: see bottom comment block
     *****************************************************************/

    const TABS = [
      { key: "myFoods",  label: "My Foods" },
      { key: "breakfast",label: "Breakfast" },
      { key: "lunch",    label: "Lunch" },
      { key: "dinner",   label: "Dinner" },
      { key: "snacks",   label: "Snacks" },
      { key: "groceries",label: "Groceries" },
    ];

    const STORAGE_KEY = "feedme_v1";

    const state = loadState();

    const elTabs = document.getElementById("tabs");
    const elPanel = document.getElementById("panel");

    const modalOverlay = document.getElementById("modalOverlay");
    const modalTitle = document.getElementById("modalTitle");
    const modalBody = document.getElementById("modalBody");
    const modalFoot = document.getElementById("modalFoot");
    
    const statFoods = document.getElementById("statFoods");
    const statRecipes = document.getElementById("statRecipes");
    const statLists = document.getElementById("statLists");
    const btnReset = document.getElementById("btnReset");
    const btnExport = document.getElementById("btnExport");
    const btnImport = document.getElementById("btnImport");
    const importFile = document.getElementById("importFile");
    let pendingImportPayload = null;
        // Grocery List multi-select session (My Foods)
    const glPickBar = document.getElementById("glPickBar");
    const glPickCount = document.getElementById("glPickCount");
    const glPickAddBtn = document.getElementById("glPickAddBtn");
    const glPickCancelBtn = document.getElementById("glPickCancelBtn");

    const glPick = {
      active: false,
      listId: null,
      selected: new Set()
    };

    glPickAddBtn.addEventListener("click", () => commitGLPickSelection());
    glPickCancelBtn.addEventListener("click", () => endGLPickSession(true));


    // ---------- Init ----------
    let activeTab = state.ui?.activeTab || "myFoods";
    // My Foods UI prefs
    state.ui = state.ui || {};
    if (typeof state.ui.foodSearch !== "string") state.ui.foodSearch = "";
    if (!state.ui.foodFilter) state.ui.foodFilter = "like_try"; // default LIKE/WILLING

    renderTabs();
    renderActivePanel();
    refreshStatsAndDatalist();

    modalOverlay.addEventListener("click", (e) => {
      if (e.target === modalOverlay) closeModal();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && modalOverlay.classList.contains("show")) closeModal();
    });

    btnReset.addEventListener("click", () => {
      if (!confirm("Reset all local Feed Me data? This cannot be undone.")) return;
      localStorage.removeItem(STORAGE_KEY);
      location.reload();
    });

    btnExport.addEventListener("click", () => exportStateToJson());
btnImport.addEventListener("click", () => importFile.click());

importFile.addEventListener("change", async () => {
  const file = importFile.files && importFile.files[0];
  importFile.value = "";
  if (!file) return;

  try{
    const text = await file.text();
    pendingImportPayload = JSON.parse(text);
    openImportOptionsModal();
  } catch {
    pendingImportPayload = null;
    alert("Import failed. The selected file does not appear to be valid JSON.");
  }
});

    // ---------- Rendering ----------
    function renderTabs(){
      elTabs.innerHTML = "";
      for (const t of TABS){
        const b = document.createElement("button");
        b.className = "tabBtn";
        b.type = "button";
        b.role = "tab";
        b.textContent = t.label;
        b.setAttribute("aria-selected", String(t.key === activeTab));
        b.addEventListener("click", () => {
          if (glPick.active) endGLPickSession(false);
          activeTab = t.key;
          state.ui = state.ui || {};
          state.ui.activeTab = activeTab;
          persist();
          renderTabs();
          renderActivePanel();
        });
        elTabs.appendChild(b);
      }
    }

    function renderActivePanel(){
      if (activeTab === "myFoods") return renderMyFoods();
      if (activeTab === "groceries") return renderGroceries();
      return renderRecipesTab(activeTab); // breakfast/lunch/dinner/snacks
    }

    // ---------- My Foods ----------
    function renderMyFoods(){
      elPanel.innerHTML = "";

      const top = panelTopRow(
        "Manage foods you like, don‚Äôt like, or are willing to try.",
        [] 
      );

      const foodsCard = document.createElement("div");
      foodsCard.className = "subCard";

      const head = document.createElement("div");
      head.className = "subHead";
head.innerHTML = `
  <h3>Foods</h3>
  <div class="row" style="gap:8px;align-items:center;flex-wrap:wrap;justify-content:flex-end;">
    <span class="chip" title="Alphabetized by Name">Sorted A‚ÜíZ</span>

    <select id="foodFilter" style="min-height:44px;border-radius:14px;border:1px solid rgba(255,255,255,0.14);background:rgba(255,255,255,0.05);color:var(--text);padding:10px 12px;font-size:14px;">
      <option value="like_try">LIKE/WILLING</option>
      <option value="all">All</option>
      <option value="like">LIKE</option>
      <option value="try">WILLING</option>
      <option value="dislike">NOT LIKE</option>
    </select>

    <input id="foodSearch" type="text" placeholder="Search foods..." style="min-height:44px;border-radius:14px;border:1px solid rgba(255,255,255,0.14);background:rgba(255,255,255,0.05);color:var(--text);padding:10px 12px;font-size:14px;min-width:220px;" />

    <button class="btn primary" type="button" id="btnAddFood">+ Food Item</button>
  </div>
`;

      foodsCard.appendChild(head);

      const wrap = document.createElement("div");
      wrap.className = "tableWrap";

      const scroll = document.createElement("div");
      scroll.className = "scrollBox";

      const table = document.createElement("table");
      table.innerHTML = `
        <thead>
          <tr>
            <th style="width:64px;">#</th>
            <th>Name</th>
            <th style="width:92px;">Like</th>
            <th style="width:120px;">Do Not Like</th>
            <th style="width:140px;">Willing To Try</th>
            <th>Notes</th>
            <th style="width:110px;">Actions</th>
          </tr>
        </thead>
        <tbody id="foodsTbody"></tbody>
      `;

      scroll.appendChild(table);
      wrap.appendChild(scroll);
      foodsCard.appendChild(wrap);

      elPanel.appendChild(top);
      elPanel.appendChild(foodsCard);

      document.getElementById("btnAddFood").addEventListener("click", () => openFoodItemModal());
      const elSearch = document.getElementById("foodSearch");
    const elFilter = document.getElementById("foodFilter");
    
    // hydrate UI
    elSearch.value = state.ui.foodSearch || "";
    elFilter.value = state.ui.foodFilter || "like_try";
    
    elSearch.addEventListener("input", () => {
      state.ui.foodSearch = elSearch.value || "";
      persist();
      renderFoodsTable();
      scrollFoodsToMatch(state.ui.foodSearch);
    });
    
    elFilter.addEventListener("change", () => {
      state.ui.foodFilter = elFilter.value || "like_try";
      persist();
      renderFoodsTable();
      scrollFoodsToMatch(state.ui.foodSearch);
    });


      renderFoodsTable();
    }

    function scrollFoodsToMatch(query){
  const q = (query || "").trim().toLowerCase();
  if (!q) return;

  const tbody = document.getElementById("foodsTbody");
  if (!tbody) return;

  // first row whose name starts with typed text
  const rows = Array.from(tbody.querySelectorAll("tr[data-foodname]"));
  const hit = rows.find(r => (r.dataset.foodname || "").startsWith(q));
  if (hit) hit.scrollIntoView({ block: "center" });
}


    function renderFoodsTable(){
      const tbody = document.getElementById("foodsTbody");
      if (!tbody) return;

      const items = getVisibleFoods();
      tbody.innerHTML = "";

      if (items.length === 0){
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td colspan="7">
            <div class="empty">No foods added yet. Tap <b>+ Food Item</b> to begin.</div>
          </td>
        `;
        tbody.appendChild(tr);
        return;
      }

      items.forEach((it, idx) => {
        const tr = document.createElement("tr");
        const isBlank = (it.pref === "none") && !(it.notes || "").trim();

        if (isBlank){
  tr.innerHTML = `
    <td><span class="chip">${idx + 1}</span></td>

<td>
  <div style="display:flex;gap:8px;align-items:center;">
    <input class="cellInput" type="text" value="${escapeAttr(it.name)}" data-id="${it.id}" data-k="name" />
    ${glPick.active
  ? `<label class="glPickLabel" title="Select for Grocery List">
       <input type="checkbox" data-act="glPick" data-id="${it.id}" ${glPick.selected.has(it.id) ? "checked" : ""} />
     </label>`
  : `<button class="glMiniBtn" type="button" data-act="gl" title="Grocery List" aria-label="Grocery List">GL</button>`
}
  </div>
</td>


    <td>
      <div class="cellChk">
        <input type="checkbox" data-id="${it.id}" data-k="like" />
      </div>
    </td>

    <td>
      <div class="cellChk">
        <input type="checkbox" data-id="${it.id}" data-k="dislike" />
      </div>
    </td>

    <td>
      <div class="cellChk">
        <input type="checkbox" data-id="${it.id}" data-k="try" />
      </div>
    </td>

    <td>
      <textarea class="cellNotes" data-id="${it.id}" data-k="notes" placeholder="Optional...">${escapeHtml(it.notes || "")}</textarea>
    </td>

    <td>
      <div style="display:flex;gap:8px;justify-content:flex-end;">
        <button class="iconBtn" type="button" data-act="edit" title="Edit" aria-label="Edit">‚úé</button>
        <button class="iconBtn danger" type="button" data-act="del" title="Delete" aria-label="Delete">üóë</button>
      </div>
    </td>
  `;

  wireInlineFoodRow(tr, it.id);
          tbody.appendChild(tr);
return;

}

          tr.innerHTML = `
  <td><span class="chip">${idx + 1}</span></td>
  <td>
  <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
    <b>${escapeHtml(it.name)}</b>
    <button class="glMiniBtn" type="button" data-act="gl" title="Grocery List" aria-label="Grocery List">GL</button>
  </div>
</td>

  <td>${it.pref === "like" ? `<span class="badgeYes">YES</span>` : `<span class="badgeNo">NO</span>`}</td>
  <td>${it.pref === "dislike" ? `<span class="badgeYes">YES</span>` : `<span class="badgeNo">NO</span>`}</td>
  <td>${it.pref === "try" ? `<span class="badgeYes">YES</span>` : `<span class="badgeNo">NO</span>`}</td>
  <td><small>${it.notes ? escapeHtml(it.notes) : ""}</small></td>
  <td>
    <div style="display:flex;gap:8px;justify-content:flex-end;">
      <button class="iconBtn" type="button" data-act="edit" title="Edit" aria-label="Edit">
        ‚úé
      </button>
      <button class="iconBtn danger" type="button" data-act="del" title="Delete" aria-label="Delete">
        üóë
      </button>
    </div>
  </td>
`;

tr.querySelector('[data-act="edit"]').addEventListener("click", (e) => {
  e.stopPropagation();
  openFoodItemModal(it);
});

tr.querySelector('[data-act="del"]').addEventListener("click", (e) => {
  e.stopPropagation();
  if (!confirm(`Delete "${it.name}"?`)) return;
  deleteFoodById(it.id);
  refreshStatsAndDatalist();
  renderFoodsTable();
});
                const pick = tr.querySelector('input[data-act="glPick"]');
        if (pick){
          pick.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!glPick.active) return;

            const on = !!pick.checked;
            if (on) glPick.selected.add(it.id);
            else glPick.selected.delete(it.id);

            updateGLPickBar();
          });
        }

        const gl = tr.querySelector('[data-act="gl"]');
        if (gl){
          gl.addEventListener("click", (e) => {
            e.stopPropagation();
            startGLFlowFromMyFoods(it);
          });
        }

        tbody.appendChild(tr);
      });
    }

    function wireInlineFoodRow(tr, id){
  const nameEl = tr.querySelector('input[data-k="name"]');
  const notesEl = tr.querySelector('textarea[data-k="notes"]');

  const likeEl = tr.querySelector('input[data-k="like"]');
  const dislikeEl = tr.querySelector('input[data-k="dislike"]');
  const tryEl = tr.querySelector('input[data-k="try"]');

  function applyExclusive(){
    const picked =
      likeEl.checked ? "like" :
      dislikeEl.checked ? "dislike" :
      tryEl.checked ? "try" : "none";

    const any = picked !== "none";
    likeEl.disabled = any && picked !== "like";
    dislikeEl.disabled = any && picked !== "dislike";
    tryEl.disabled = any && picked !== "try";

    return picked;
  }

  function save(){
    const newName = (nameEl.value || "").trim();
    const newNotes = (notesEl.value || "").trim();
    const pref = applyExclusive();

    // Require name to keep row valid
    if (!newName) return;

    // Prevent accidental duplicates by name (case-insensitive) across different IDs
    const dup = state.foods.find(f => f.id !== id && f.name.trim().toLowerCase() === newName.toLowerCase());
    if (dup){
      alert(`"${newName}" already exists.`);
      // revert visible name to stored value
      const cur = state.foods.find(f => f.id === id);
      nameEl.value = cur ? cur.name : newName;
      return;
    }

    updateFoodById(id, { name: newName, notes: newNotes, pref });

    refreshStatsAndDatalist();
    renderFoodsTable(); // re-sorts and updates numbering
  }

  // Save on click-away
  nameEl.addEventListener("blur", save);
  notesEl.addEventListener("blur", save);

  // Save on Enter (Name)
  nameEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      e.preventDefault();
      nameEl.blur(); // triggers save
    }
  });

  // Checkboxes: enforce exclusivity + save
  function onPick(which){
    if (which === "like" && likeEl.checked){ dislikeEl.checked = false; tryEl.checked = false; }
    if (which === "dislike" && dislikeEl.checked){ likeEl.checked = false; tryEl.checked = false; }
    if (which === "try" && tryEl.checked){ likeEl.checked = false; dislikeEl.checked = false; }
    applyExclusive();
    save();
  }

  likeEl.addEventListener("change", () => onPick("like"));
  dislikeEl.addEventListener("change", () => onPick("dislike"));
  tryEl.addEventListener("change", () => onPick("try"));

  // Initial state
  applyExclusive();

        const pickChk = tr.querySelector('input[data-act="glPick"]');
  if (pickChk){
    pickChk.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, { passive:false });

    pickChk.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (!glPick.active) return;

      const on = !!pickChk.checked;
      if (on) glPick.selected.add(id);
      else glPick.selected.delete(id);

      updateGLPickBar();
    });

    // If checkbox exists, we are in pick mode; don't wire GL button.
  }
      const glBtn = tr.querySelector('[data-act="gl"]');
if (glBtn){
  // prevent the button from stealing focus and causing blur-driven rerenders
  glBtn.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    e.stopPropagation();
  }, { passive:false });

  glBtn.addEventListener("click", (e) => {
    e.preventDefault();
    e.stopPropagation();

    // use the current typed values (even if not yet saved)
    const cur = state.foods.find(x => x.id === id);
    if (!cur) return;

    const clicked = {
      ...cur,
      name: (nameEl.value || "").trim() || cur.name,
      notes: (notesEl.value || "").trim(),
      pref: applyExclusive()
    };

    startGLFlowFromMyFoods(clicked);
  });
}



  // Keep your existing action buttons behavior
  tr.querySelector('[data-act="edit"]').addEventListener("click", (e) => {
    e.stopPropagation();
    const it = state.foods.find(x => x.id === id);
    if (it) openFoodItemModal(it);
  });

  tr.querySelector('[data-act="del"]').addEventListener("click", (e) => {
    e.stopPropagation();
    const it = state.foods.find(x => x.id === id);
    const nm = it?.name || "this item";
    if (!confirm(`Delete "${nm}"?`)) return;
    deleteFoodById(id);
    refreshStatsAndDatalist();
    renderFoodsTable();
  });
}


    function openFoodItemModal(existing){
      const isEdit = !!existing;
      const model = existing ? deepClone(existing) : {
        id: cryptoId(),
        name: "",
        pref: "none", // "like" | "dislike" | "try" | "none"
        notes: "",
        createdAt: Date.now()
      };

      openModal({
        title: isEdit ? "Edit Food Item" : "Add Food Item",
        body: () => {
          const box = document.createElement("div");
          box.innerHTML = `
            <div class="grid5">
              <div class="field">
                <label>Name</label>
                <input type="text" id="foodName" placeholder="e.g., Broccoli" value="${escapeAttr(model.name)}" />
                <div class="hint">Single line food name.</div>
              </div>

              <div class="field">
                <label>Like</label>
                <div class="inline">
                  <label class="chk">
                    <input type="checkbox" id="chkLike" ${model.pref==="like" ? "checked" : ""} />
                    <span>Yes</span>
                  </label>
                </div>
                <div class="hint">Select one preference.</div>
              </div>

              <div class="field">
                <label>Do Not Like</label>
                <div class="inline">
                  <label class="chk">
                    <input type="checkbox" id="chkDislike" ${model.pref==="dislike" ? "checked" : ""} />
                    <span>Yes</span>
                  </label>
                </div>
                <div class="hint">Select one preference.</div>
              </div>

              <div class="field">
                <label>Willing to Try</label>
                <div class="inline">
                  <label class="chk">
                    <input type="checkbox" id="chkTry" ${model.pref==="try" ? "checked" : ""} />
                    <span>Yes</span>
                  </label>
                </div>
                <div class="hint">Select one preference.</div>
              </div>

              <div class="field">
                <label>Notes</label>
                <textarea id="foodNotes" placeholder="e.g., I only eat it cooked.">${escapeHtml(model.notes || "")}</textarea>
                <div class="hint">Extra info about the food item.</div>
              </div>
            </div>
          `;

          // Exclusive checkbox enforcement
          const chkLike = box.querySelector("#chkLike");
          const chkDislike = box.querySelector("#chkDislike");
          const chkTry = box.querySelector("#chkTry");

          function applyExclusive(){
            const picked = chkLike.checked ? "like" : chkDislike.checked ? "dislike" : chkTry.checked ? "try" : "none";
            model.pref = picked;

            const any = picked !== "none";
            chkLike.disabled = any && picked !== "like";
            chkDislike.disabled = any && picked !== "dislike";
            chkTry.disabled = any && picked !== "try";
          }

          [chkLike, chkDislike, chkTry].forEach(chk => {
            chk.addEventListener("change", () => {
              // if turning one on, turn others off
              if (chk === chkLike && chkLike.checked){ chkDislike.checked = false; chkTry.checked = false; }
              if (chk === chkDislike && chkDislike.checked){ chkLike.checked = false; chkTry.checked = false; }
              if (chk === chkTry && chkTry.checked){ chkLike.checked = false; chkDislike.checked = false; }
              applyExclusive();
            });
          });

          applyExclusive();
          return box;
        },
footer: ({ close }) => {
  const btnClose = mkBtn("Close", "ghost", () => { close(); openRecipeModal(mealKey, model); });
  const btnSave = mkBtn("Save", "primary", () => {
    const name = (document.getElementById("foodName").value || "").trim();
    const notes = (document.getElementById("foodNotes").value || "").trim();

    if (!name){
      alert("Name is required for a Food Item.");
      return;
    }

    model.name = name;
    model.notes = notes;

    upsertFood(model);

    close();
    refreshStatsAndDatalist();
    renderFoodsTable();
  });

  return [btnClose, btnSave];
}


      });
    }

    function deleteFoodById(id){
  const idx = state.foods.findIndex(x => x.id === id);
  if (idx >= 0){
    state.foods.splice(idx, 1);
    persist();
  }
}
    function updateFoodById(id, patch){
  const idx = state.foods.findIndex(x => x.id === id);
  if (idx < 0) return;

  state.foods[idx] = { ...state.foods[idx], ...patch };
  persist();
}

    function upsertFood(item){
      // If same name already exists (case-insensitive), update that record instead of duplicating
      const idx = state.foods.findIndex(x => x.name.trim().toLowerCase() === item.name.trim().toLowerCase());
      if (idx >= 0){
        // preserve original id/createdAt; update preference/notes if provided
        const existing = state.foods[idx];
        state.foods[idx] = {
          ...existing,
          ...item,
          id: existing.id,
          createdAt: existing.createdAt
        };
      } else {
        state.foods.push(item);
      }
      persist();
    }

    function getFoodsSorted(){
      return [...state.foods].sort((a,b) => a.name.localeCompare(b.name, undefined, { sensitivity:"base" }));
    }

    function getVisibleFoods(){
  const q = (state.ui.foodSearch || "").trim().toLowerCase();
  const f = state.ui.foodFilter || "like_try";

  let items = getFoodsSorted();

  // Filter by preference
  items = items.filter(it => {
    const pref = it.pref || "none";
    if (f === "all") return true;
    if (f === "like") return pref === "like";
    if (f === "try") return pref === "try";
    if (f === "dislike") return pref === "dislike";
    if (f === "like_try") return pref === "like" || pref === "try";
    return true;
  });

  // Search by name (contains)
  if (q){
    items = items.filter(it => ((it.name || "").toLowerCase()).includes(q));
  }

  return items;
}

    

    // ---------- Recipes Tabs ----------
    function renderRecipesTab(mealKey){
      elPanel.innerHTML = "";

      const label = TABS.find(t => t.key === mealKey)?.label || "Recipes";
      const recipes = state.recipes[mealKey] || [];

      const top = panelTopRow(
        `Store ${label.toLowerCase()} recipes. Tap a card to view or edit.`,
        [
          { label:"+ Recipe", cls:"primary", onClick: () => openRecipeModal(mealKey) }
        ]
      );

      elPanel.appendChild(top);

      if (recipes.length === 0){
        const empty = document.createElement("div");
        empty.className = "empty";
        empty.innerHTML = `No recipes yet. Tap <b>+ Recipe</b> to add your first ${escapeHtml(label.toLowerCase())} recipe.`;
        elPanel.appendChild(empty);
        return;
      }

      const cards = document.createElement("div");
      cards.className = "cards";

      recipes
        .slice()
        .sort((a,b) => (b.updatedAt||b.createdAt) - (a.updatedAt||a.createdAt))
        .forEach(r => {
          const c = document.createElement("div");
          c.className = "miniCard";
          c.addEventListener("click", () => openRecipeViewerModal(mealKey, r.id));

          const dt = new Date(r.updatedAt || r.createdAt);
          c.innerHTML = `
            <div class="miniTop">
              <h4 class="miniTitle">${escapeHtml(r.title || "(Untitled Recipe)")}</h4>
              <div class="miniMeta">${fmtDateTime(dt)}</div>
            </div>
          
            <div class="miniBody">
              ${recipePreviewHtml(r)}
            </div>
          
            <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
              <button class="iconBtn" type="button" data-act="edit" title="Edit" aria-label="Edit">‚úé</button>
              <button class="iconBtn danger" type="button" data-act="del" title="Delete" aria-label="Delete">üóë</button>
            </div>
          `;
          c.querySelector('[data-act="edit"]').addEventListener("click", (e) => {
          e.stopPropagation();
          openRecipeModal(mealKey, r);
        });
        
        c.querySelector('[data-act="del"]').addEventListener("click", (e) => {
          e.stopPropagation();
          if (!confirm(`Delete "${r.title || "Untitled Recipe"}"?`)) return;
          deleteRecipe(mealKey, r.id);
          refreshStatsAndDatalist();
          renderActivePanel();
        });


          cards.appendChild(c);
        });

      elPanel.appendChild(cards);
    }

    function openRecipeModal(mealKey, existing){
      const isEdit = !!existing;
      const model = existing ? deepClone(existing) : {
        id: cryptoId(),
        title: "",
        servings: "",
        time: "",
        ingredientsItems: [],   // <-- new
        stepsItems: [],         // <-- new (array of strings)
        notes: "",
        createdAt: Date.now(),
        updatedAt: null
      };

      // Backward-compat for older recipes that stored ingredients/steps as strings
      if (!Array.isArray(model.ingredientsItems)){
        model.ingredientsItems = [];
        const legacy = (model.ingredients || "").trim();
        if (legacy) {
          legacy.split(/\r?\n/).filter(Boolean).forEach(line => {
            model.ingredientsItems.push({ name: line.trim(), qty:"", unit:"", notes:"", addToGroceries:false });
          });
        }
      }
      if (!Array.isArray(model.stepsItems)){
        const legacyS = (model.steps || "").trim();
        model.stepsItems = legacyS ? legacyS.split(/\r?\n/).map(s => s.replace(/^‚Ä¢\s*/,"").trim()).filter(Boolean) : [];
      }
      delete model.ingredients;
      delete model.steps;



      openModal({
        title: isEdit ? "Edit Recipe" : "Add Recipe",
        body: () => {
          const box = document.createElement("div");
          box.innerHTML = `
            <div class="field">
              <label>Recipe Name</label>
              <input type="text" id="rTitle" placeholder="e.g., Chicken & Rice Bowl" value="${escapeAttr(model.title)}" />
            </div>

            <div class="row" style="margin-top:12px;">
              <div class="field" style="flex:1;min-width:180px;">
                <label>Servings</label>
                <input type="text" id="rServings" placeholder="e.g., 2" value="${escapeAttr(model.servings)}" />
              </div>
              <div class="field" style="flex:1;min-width:180px;">
                <label>Total Time</label>
                <input type="text" id="rTime" placeholder="e.g., 25 minutes" value="${escapeAttr(model.time)}" />
              </div>
            </div>

          <div class="subCard" style="padding:12px;margin-top:12px;">
            <div class="panelTop" style="margin:0 0 10px 0;">
              <div class="panelTitle">Ingredients (add rows like Groceries). Names autofill from My Foods.</div>
              <div class="actions">
                <button class="btn ghost" type="button" id="btnAddRIng">+ Item</button>
              </div>
            </div>
          
            <div class="listItems" id="rIngWrap"></div>
          </div>
          
          <div class="subCard" style="padding:12px;margin-top:12px;">
            <div class="panelTop" style="margin:0 0 10px 0;">
              <div class="panelTitle">Steps (saved as bullet points).</div>
              <div class="actions">
                <button class="btn ghost" type="button" id="btnAddRStep">+ Step</button>
              </div>
            </div>
          
            <div id="rStepsWrap"></div>
          </div>
          

            <div class="field" style="margin-top:12px;">
              <label>Notes</label>
              <textarea id="rNotes" placeholder="Any extra notes...">${escapeHtml(model.notes || "")}</textarea>
            </div>
          `;

          // Attach datalist-based suggestion behavior for ingredients
          setTimeout(() => {
  const btnAdd = box.querySelector("#btnAddRIng");
  const wrap = box.querySelector("#rIngWrap");

  function blankIng(){
    return { name:"", qty:"", unit:"", notes:"", addToGroceries:false };
  }

  function renderIngredients(){
    wrap.innerHTML = "";

    model.ingredientsItems = Array.isArray(model.ingredientsItems) ? model.ingredientsItems : [];
    if (!model.ingredientsItems.length) model.ingredientsItems.push(blankIng());

    model.ingredientsItems.forEach((it, idx) => {
      const row = document.createElement("div");
      row.className = "listRow";
      row.innerHTML = `
        <div class="field">
          <label>Item</label>
          <input type="text" data-k="name" data-i="${idx}" list="foodsDatalist" placeholder="e.g., Broccoli" value="${escapeAttr(it.name)}" />
        </div>

        <div class="field">
          <label>Qty</label>
          <input type="number" step="0.01" data-k="qty" data-i="${idx}" placeholder="e.g., 2" value="${escapeAttr(it.qty)}" />
        </div>

        <div class="field">
          <label>Unit</label>
          <select data-k="unit" data-i="${idx}">
            ${unitOptions(it.unit)}
          </select>
        </div>

        <div class="field">
          <label>Notes</label>
          <textarea data-k="notes" data-i="${idx}" placeholder="Optional...">${escapeHtml(it.notes||"")}</textarea>
        </div>

        <div class="field">
          <label>Add to Grocery List</label>
          <div class="inline">
            <label class="chk">
              <input type="checkbox" data-k="addToGroceries" data-i="${idx}" ${it.addToGroceries ? "checked" : ""} />
              <span>Yes</span>
            </label>
          </div>
          <div class="hint">If checked, can be pushed into Groceries later.</div>
        </div>
      `;

      const actions = document.createElement("div");
      actions.className = "listRowActions";
      actions.style.gridColumn = "1 / -1";
      actions.innerHTML = `
        <button class="btn ghost" type="button" data-act="dup" data-i="${idx}">Duplicate</button>
        <button class="btn danger" type="button" data-act="del" data-i="${idx}">Remove</button>
      `;
      row.appendChild(actions);
      wrap.appendChild(row);
    });

    // bind changes
    wrap.querySelectorAll("input, textarea, select").forEach(inp => {
      const k = inp.dataset.k;
      const i = +inp.dataset.i;

      const apply = () => {
        if (!model.ingredientsItems[i]) return;
        if (k === "addToGroceries") model.ingredientsItems[i][k] = !!inp.checked;
        else model.ingredientsItems[i][k] = inp.value ?? "";
      };

      inp.addEventListener("input", apply);
      inp.addEventListener("change", apply);
    });

    // actions
    wrap.querySelectorAll("button[data-act]").forEach(b => {
      b.addEventListener("click", () => {
        const i = +b.dataset.i;
        const act = b.dataset.act;
        if (act === "del"){
          model.ingredientsItems.splice(i, 1);
          if (!model.ingredientsItems.length) model.ingredientsItems.push(blankIng());
          renderIngredients();
        }
        if (act === "dup"){
          model.ingredientsItems.splice(i+1, 0, deepClone(model.ingredientsItems[i]));
          renderIngredients();
        }
      });
    });
  }

  btnAdd.addEventListener("click", () => {
    model.ingredientsItems.push(blankIng());
    renderIngredients();
  });

  renderIngredients();
}, 0);

 setTimeout(() => {
  const btn = box.querySelector("#btnAddRStep");
  const wrap = box.querySelector("#rStepsWrap");

  function renderSteps(){
    wrap.innerHTML = "";
    const steps = Array.isArray(model.stepsItems) ? model.stepsItems : [];
    if (!steps.length){
      wrap.innerHTML = `<div class="empty">No steps yet. Tap <b>+ Step</b> to add bullet points.</div>`;
      return;
    }

    const card = document.createElement("div");
    card.className = "subCard";
    card.style.padding = "12px";
    card.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:8px;">
        ${steps.map((s, i) => `
          <div style="display:flex;gap:10px;align-items:flex-start;">
            <div class="chip" style="min-width:44px;text-align:center;">${i+1}</div>
            <div style="flex:1;white-space:pre-wrap;line-height:1.45;">‚Ä¢ ${escapeHtml(s)}</div>
            <button class="iconBtn danger" type="button" data-delstep="${i}" title="Delete step" aria-label="Delete step">üóë</button>
          </div>
        `).join("")}
      </div>
    `;
    wrap.appendChild(card);

    card.querySelectorAll("button[data-delstep]").forEach(b => {
      b.addEventListener("click", () => {
        const i = +b.dataset.delstep;
        model.stepsItems.splice(i, 1);
        renderSteps();
      });
    });
  }

btn.addEventListener("click", () => {
  openModal({
    title: "Add Step",
    body: () => {
      const b = document.createElement("div");
      b.innerHTML = `
        <div class="field">
          <label>Step</label>
          <textarea id="newStepText" placeholder="Type one or multiple steps. New lines become separate bullets."></textarea>
        </div>
      `;
      return b;
    },
    footer: ({ close }) => {
      const btnClose = mkBtn("Close", "ghost", () => {
        close();
        openRecipeModal(mealKey, model);
      });

      const btnSave = mkBtn("Save", "primary", () => {
        const txt = (document.getElementById("newStepText").value || "").trim();
        if (txt){
          const lines = txt.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          model.stepsItems = Array.isArray(model.stepsItems) ? model.stepsItems : [];
          model.stepsItems.push(...lines);
        }
        close();
        openRecipeModal(mealKey, model);
      });

      return [btnClose, btnSave];
    }
  });
});
  renderSteps();
}, 0);
     

          return box;
        },
        footer: ({ close }) => {
          const btnClose = mkBtn("Close", "ghost", () => close());
          const btnSave = mkBtn("Save", "primary", () => {
            model.title = (document.getElementById("rTitle").value || "").trim();
            model.servings = (document.getElementById("rServings").value || "").trim();
            model.time = (document.getElementById("rTime").value || "").trim();
            model.notes = (document.getElementById("rNotes").value || "").trim();

          if (isEdit){
              model.updatedAt = Date.now();
              updateRecipe(mealKey, model);
            } else {
              addRecipe(mealKey, model);
            }

            close();
            refreshStatsAndDatalist();
            renderActivePanel();
          });

          return [btnClose, btnSave];
        }
      });
    }

    function openRecipeViewerModal(mealKey, id){
      const r = (state.recipes[mealKey] || []).find(x => x.id === id);
      if (!r) return;

      openModal({
        title: r.title || "(Untitled Recipe)",
        body: () => {
          const box = document.createElement("div");
          const dt = new Date(r.updatedAt || r.createdAt);
          box.innerHTML = `
            <div class="row" style="justify-content:space-between;gap:10px;margin-bottom:10px;">
              <div class="chip">${fmtDateTime(dt)}</div>
              <div class="chip">${escapeHtml(TABS.find(t=>t.key===mealKey)?.label || mealKey)}</div>
            </div>

            <div class="subCard" style="padding:12px;">
              ${viewerField("Servings", r.servings)}
              ${viewerField("Total Time", r.time)}
              <div class="hr"></div>
              ${viewerBlock("Ingredients", formatIngredientsForViewer(r.ingredientsItems))}
              ${viewerBlock("Steps", formatStepsForViewer(r.stepsItems))}
              ${viewerBlock("Notes", r.notes)}
            </div>
          `;
          return box;
        },
      footer: ({ close }) => {
        const btnClose = mkBtn("Close", "ghost", () => close());
      
        const btnEdit = mkBtn("Edit", "primary", () => {
          close();
          openRecipeModal(mealKey, r);
        });
      
        const btnDelete = mkBtn("Delete", "danger", () => {
          if (!confirm(`Delete "${r.title || "Untitled Recipe"}"?`)) return;
          deleteRecipe(mealKey, r.id);
          close();
          refreshStatsAndDatalist();
          renderActivePanel();
        });
      
        return [btnClose, btnEdit, btnDelete];
      }
      });
    }

      function addRecipe(mealKey, recipe){
      state.recipes[mealKey] = state.recipes[mealKey] || [];
      state.recipes[mealKey].push(recipe);
      persist();
    }
    function updateRecipe(mealKey, recipe){
      const list = state.recipes[mealKey] || [];
      const idx = list.findIndex(x => x.id === recipe.id);
      if (idx >= 0) list[idx] = recipe;
      persist();
    }
    function deleteRecipe(mealKey, id){
  const list = state.recipes[mealKey] || [];
  const idx = list.findIndex(x => x.id === id);
  if (idx >= 0){
    list.splice(idx, 1);
    persist();
  }
}


    function recipePreviewHtml(r){
      const lines = [];
      if (r.time) lines.push(`<div><span class="muted">Time:</span> ${escapeHtml(r.time)}</div>`);
      if (r.servings) lines.push(`<div><span class="muted">Serves:</span> ${escapeHtml(r.servings)}</div>`);
const ingLines = Array.isArray(r.ingredientsItems)
  ? r.ingredientsItems.filter(x => (x.name||"").trim()).map(x => x.name.trim())
  : [];
const stepLines = Array.isArray(r.stepsItems) ? r.stepsItems : [];
if (ingLines.length) lines.push(`<div style="margin-top:6px;"><span class="muted">Ingredients:</span><br>${escapeHtml(ingLines.slice(0,6).join("\n")).replaceAll("\n","<br>")}${ingLines.length>6 ? `<br><span class="muted">‚Ä¶and more</span>`:""}</div>`);
if (stepLines.length) lines.push(`<div style="margin-top:6px;"><span class="muted">Steps:</span><br>${escapeHtml(stepLines.slice(0,4).map(s=>"‚Ä¢ "+s).join("\n")).replaceAll("\n","<br>")}${stepLines.length>4 ? `<br><span class="muted">‚Ä¶and more</span>`:""}</div>`);
if (lines.length === 0) return `<div class="muted">No details yet.</div>`;
      return lines.join("");
    }


    function foodToGroceryItem(food){
  const nm = (food?.name || "").trim();
  if (!nm) return null;
  return {
    name: nm,
    qty: "",
    unit: "",
    notes: (food?.notes || "").trim(),
    description: "",
    done: false
  };
}

function addItemsToGroceryList(listId, foods){
  const list = state.groceryLists.find(x => x.id === listId);
  if (!list) return;

  list.items = Array.isArray(list.items) ? list.items : [];
  const seen = new Set(list.items.map(it => (it.name || "").trim().toLowerCase()).filter(Boolean));

  (foods || []).forEach(f => {
    const gi = foodToGroceryItem(f);
    if (!gi) return;
    const key = gi.name.toLowerCase();
    if (seen.has(key)) return; // dedupe
    seen.add(key);
    list.items.push(gi);
  });

  list.updatedAt = Date.now();
  persist();
}

    function escCss(s){
  try { return (window.CSS && CSS.escape) ? CSS.escape(String(s)) : String(s).replace(/["\\]/g, "\\$&"); }
  catch { return String(s).replace(/["\\]/g, "\\$&"); }
}

function updateGLPickBar(){
  if (!glPickBar) return;

  if (!glPick.active){
    glPickBar.classList.remove("show");
    glPickBar.setAttribute("aria-hidden", "true");
    return;
  }

  glPickBar.classList.add("show");
  glPickBar.setAttribute("aria-hidden", "false");

  const n = glPick.selected.size;
  if (glPickCount) glPickCount.textContent = String(n);
  if (glPickAddBtn) glPickAddBtn.disabled = (n === 0);
}

function beginGLPickSession(listId, preselectId){
  glPick.active = true;
  glPick.listId = listId;
  glPick.selected = new Set();

  if (preselectId) glPick.selected.add(preselectId);

  updateGLPickBar();
  renderFoodsTable(); // swap GL buttons to checkboxes
}

function endGLPickSession(rerender){
  glPick.active = false;
  glPick.listId = null;
  glPick.selected = new Set();
  updateGLPickBar();
  if (rerender) renderFoodsTable(); // bring GL buttons back
}

// If user is editing an inline "blank" row, capture current typed values at add-time.
function foodSnapshotForGL(id){
  const stored = state.foods.find(f => f.id === id);
  if (!stored) return null;

  const nmEl = document.querySelector(`input[data-id="${escCss(id)}"][data-k="name"]`);
  if (!nmEl) return stored;

  const notesEl = document.querySelector(`textarea[data-id="${escCss(id)}"][data-k="notes"]`);
  const likeEl = document.querySelector(`input[data-id="${escCss(id)}"][data-k="like"]`);
  const dislikeEl = document.querySelector(`input[data-id="${escCss(id)}"][data-k="dislike"]`);
  const tryEl = document.querySelector(`input[data-id="${escCss(id)}"][data-k="try"]`);

  const pref =
    likeEl?.checked ? "like" :
    dislikeEl?.checked ? "dislike" :
    tryEl?.checked ? "try" : (stored.pref || "none");

  return {
    ...stored,
    name: (nmEl.value || "").trim() || stored.name,
    notes: (notesEl?.value || "").trim(),
    pref
  };
}

function commitGLPickSelection(){
  if (!glPick.active || !glPick.listId) return;

  const list = state.groceryLists.find(x => x.id === glPick.listId);
  if (!list){
    alert("Target grocery list not found.");
    endGLPickSession(true);
    return;
  }

  const before = (list.items?.length || 0);

  const foods = Array.from(glPick.selected)
    .map(id => foodSnapshotForGL(id))
    .filter(f => f && (f.name || "").trim());

  if (!foods.length){
    alert("No valid items selected.");
    return;
  }

  addItemsToGroceryList(glPick.listId, foods);

  const after = (list.items?.length || 0);
  const added = Math.max(0, after - before);

  endGLPickSession(true);
  refreshStatsAndDatalist();

  alert(`Added ${added} item${added === 1 ? "" : "s"} to the grocery list.`);
}


function startGLFlowFromMyFoods(clickedFood){
  // Step 1: Single or Multiple
  openModal({
    title: "Grocery List",
    body: () => {
      const box = document.createElement("div");
      box.innerHTML = `
        <div class="field">
          <label>Single or Multiple Items?</label>
         <div class="hint">Single adds the item you clicked. Multiple lets you pick a list first, then select items manually.</div>
        </div>
      `;
      return box;
    },
    footer: ({ close }) => {
      const btnSingle = mkBtn("Single", "primary", () => {
        close();
        const foods = [clickedFood];
        chooseNewOrAddGL(foods);
      });

      const btnMulti = mkBtn("Multiple", "ghost", () => {
        close();
        chooseGLDestinationThenSelect(clickedFood);
      });


      const btnCancel = mkBtn("Cancel", "ghost", () => close());

      return [btnCancel, btnSingle, btnMulti];
    }
  });
}

 function chooseGLDestinationThenSelect(clickedFood){
  openModal({
    title: "Multiple Items",
    body: () => {
      const box = document.createElement("div");
      box.innerHTML = `
        <div class="field">
          <label>Where do you want to add items?</label>
          <div class="hint">Choose the target grocery list first. Then the GL buttons turn into checkboxes so you can select exactly what you want.</div>
        </div>
      `;
      return box;
    },
    footer: ({ close }) => {
      const btnNew = mkBtn("New GL", "primary", () => {
        close();

        const list = {
          id: cryptoId(),
          createdAt: Date.now(),
          updatedAt: null,
          items: []
        };
        state.groceryLists.push(list);
        persist();

        // start selection mode (preselect the clicked food)
        beginGLPickSession(list.id, clickedFood?.id);
      });

      const btnAdd = mkBtn("Add to GL", "ghost", () => {
        close();
        openPickGroceryListModalForPick(clickedFood?.id);
      });

      const btnCancel = mkBtn("Cancel", "ghost", () => close());

      return [btnCancel, btnNew, btnAdd];
    }
  });
}

function openPickGroceryListModalForPick(preselectId){
  const lists = state.groceryLists
    .slice()
    .sort((a,b) => (b.updatedAt||b.createdAt) - (a.updatedAt||a.createdAt));

  if (!lists.length){
    alert("No grocery lists exist yet. Choose New GL instead.");
    return;
  }

  openModal({
    title: "Pick Grocery List",
    body: () => {
      const box = document.createElement("div");
      const wrap = document.createElement("div");
      wrap.className = "subCard";
      wrap.style.padding = "12px";
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "10px";

      lists.forEach(l => {
        const dt = new Date(l.updatedAt || l.createdAt);
        const count = l.items?.length || 0;

        const b = document.createElement("button");
        b.type = "button";
        b.className = "btn ghost";
        b.style.justifyContent = "space-between";
        b.innerHTML = `<span style="font-weight:800;">Grocery List</span><span class="chip">${fmtDateTime(dt)} ‚Ä¢ ${count} items</span>`;
        b.addEventListener("click", () => {
          closeModal(); // close picker
          beginGLPickSession(l.id, preselectId);
        });

        wrap.appendChild(b);
      });

      box.appendChild(wrap);
      return box;
    },
    footer: ({ close }) => {
      const btnClose = mkBtn("Close", "ghost", () => close());
      return [btnClose];
    }
  });
}
   

function chooseNewOrAddGL(foods){
  const usable = (foods || []).filter(f => (f.name || "").trim());
  if (!usable.length){
    alert("No items available to add.");
    return;
  }

  openModal({
    title: "Grocery List",
    body: () => {
      const box = document.createElement("div");
      box.innerHTML = `
        <div class="field">
          <label>New GL or Add to GL?</label>
          <div class="hint">New GL creates a new grocery list with these items. Add to GL lets you pick an existing list.</div>
        </div>
      `;
      return box;
    },
    footer: ({ close }) => {
      const btnNew = mkBtn("New GL", "primary", () => {
        close();
        const list = {
          id: cryptoId(),
          createdAt: Date.now(),
          updatedAt: null,
          items: []
        };

        // add now, then persist
        state.groceryLists.push(list);
        persist();

        addItemsToGroceryList(list.id, usable);

        // jump to Groceries and open viewer
        activeTab = "groceries";
        state.ui.activeTab = activeTab;
        persist();
        renderTabs();
        renderActivePanel();
        openGroceryViewerModal(list.id);
      });

      const btnAdd = mkBtn("Add to GL", "ghost", () => {
        close();
        openPickGroceryListModal(usable);
      });

      const btnCancel = mkBtn("Cancel", "ghost", () => close());
      return [btnCancel, btnNew, btnAdd];
    }
  });
}

function openPickGroceryListModal(foods){
  const lists = state.groceryLists
    .slice()
    .sort((a,b) => (b.updatedAt||b.createdAt) - (a.updatedAt||a.createdAt));

  if (!lists.length){
    alert("No grocery lists exist yet. Choose New GL instead.");
    return;
  }

  openModal({
    title: "Add to Grocery List",
    body: () => {
      const box = document.createElement("div");
      const wrap = document.createElement("div");
      wrap.className = "subCard";
      wrap.style.padding = "12px";
      wrap.style.display = "flex";
      wrap.style.flexDirection = "column";
      wrap.style.gap = "10px";

      lists.forEach(l => {
        const dt = new Date(l.updatedAt || l.createdAt);
        const count = l.items?.length || 0;

        const b = document.createElement("button");
        b.type = "button";
        b.className = "btn ghost";
        b.style.justifyContent = "space-between";
        b.innerHTML = `<span style="font-weight:800;">Grocery List</span><span class="chip">${fmtDateTime(dt)} ‚Ä¢ ${count} items</span>`;
        b.addEventListener("click", () => {
          addItemsToGroceryList(l.id, foods);
          closeModal(); // close picker
          refreshStatsAndDatalist();
          activeTab = "groceries";
          state.ui.activeTab = activeTab;
          persist();
          renderTabs();
          renderActivePanel();
          openGroceryViewerModal(l.id);
        });

        wrap.appendChild(b);
      });

      box.appendChild(wrap);
      return box;
    },
    footer: ({ close }) => {
      const btnClose = mkBtn("Close", "ghost", () => close());
      return [btnClose];
    }
  });
}

    
    // ---------- Groceries ----------
    function foodByNameCI(name){
  const n = (name || "").trim().replace(/\s+/g," ").toLowerCase();
  if (!n) return null;
  return state.foods.find(f => (f.name || "").trim().replace(/\s+/g," ").toLowerCase() === n) || null;
}

function prefClassForFoodName(name){
  const f = foodByNameCI(name);
  if (!f) return "";
  if (f.pref === "like") return "gNameLike";
  if (f.pref === "try") return "gNameTry";
  return "";
}

function hasFoodNote(name){
  const f = foodByNameCI(name);
  return !!((f?.notes || "").trim());
}

function foodNoteText(name){
  const f = foodByNameCI(name);
  return (f?.notes || "").trim();
}

// Build default grocery list items from ALL foods marked Like=YES or Willing To Try=YES
function buildDefaultGroceryItemsFromPrefs(){
  const seen = new Set();
  const out = [];

  // Use sorted foods so the default list is stable/pleasant
  const foods = getFoodsSorted();
  foods.forEach(f => {
    if (f.pref !== "like" && f.pref !== "try") return;

    const nm = (f.name || "").trim();
    if (!nm) return;
    const key = nm.toLowerCase();
    if (seen.has(key)) return;
    seen.add(key);

out.push({
  name: nm,
  qty: "",
  unit: "",
  // include My Foods notes into the grocery Notes field
  notes: (f.notes || "").trim(),
  description: "",
  done: false
});
  });

  return out;
}

// ---- Qty: allow only quarter steps (x.00, x.25, x.50, x.75) ----
function sanitizeQtyInput(raw){
  // allow digits + one dot
  let s = String(raw ?? "");
  s = s.replace(/[^\d.]/g, "");
  const firstDot = s.indexOf(".");
  if (firstDot !== -1){
    s = s.slice(0, firstDot + 1) + s.slice(firstDot + 1).replace(/\./g, "");
  }
  return s;
}

function snapToQuarterString(raw){
  const s = String(raw ?? "").trim();
  if (!s) return "";
  const v = Number(s);
  if (!Number.isFinite(v)) return "";

  const snapped = Math.round(v * 4) / 4;

  // Format: 1, 1.25, 1.5, 1.75, etc.
  let out = snapped.toFixed(2);
  out = out.replace(/\.00$/,"").replace(/0$/,"");
  return out;
}

// Name display for preview/readonly with color + asterisk
function groceryNameHtml(name){
  const safe = escapeHtml(name || "");
  const cls = prefClassForFoodName(name);
  const star = hasFoodNote(name)
    ? ` <span class="muted" title="Check notes">*</span>`
    : "";
  return `<span class="${cls}">${safe || "<span class='muted'>(Unnamed)</span>"}</span>${star}`;
}

function renderGroceries(){
  elPanel.innerHTML = "";

  const top = panelTopRow(
    "Create grocery lists. Tap a list card to view or edit.",
    [
      { label:"+ New List", cls:"primary", onClick: () => openGroceryListModal() }
    ]
  );

  elPanel.appendChild(top);

  const lists = state.groceryLists
    .slice()
    .sort((a,b) => (b.updatedAt||b.createdAt) - (a.updatedAt||a.createdAt));

  if (lists.length === 0){
    const empty = document.createElement("div");
    empty.className = "empty";
    empty.innerHTML = `No grocery lists yet. Tap <b>+ New List</b> to create one.`;
    elPanel.appendChild(empty);
    return;
  }

  const cards = document.createElement("div");
  cards.className = "cards";

  lists.forEach(list => {
    const c = document.createElement("div");
    c.className = "miniCard";
    c.addEventListener("click", () => openGroceryViewerModal(list.id));

    const dt = new Date(list.updatedAt || list.createdAt);
    const count = list.items?.length || 0;

    c.innerHTML = `
      <div class="miniTop">
        <h4 class="miniTitle">Grocery List</h4>
        <div class="miniMeta">${fmtDateTime(dt)}</div>
      </div>

      <div class="miniBody">
        <div><span class="muted">Items:</span> ${count}</div>
        <div style="margin-top:6px;">
          ${groceryPreviewHtml(list)}
        </div>
      </div>

      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:8px;">
        <button class="iconBtn" type="button" data-act="edit" title="Edit" aria-label="Edit">‚úé</button>
        <button class="iconBtn danger" type="button" data-act="del" title="Delete" aria-label="Delete">üóë</button>
      </div>
    `;

    c.querySelector('[data-act="edit"]').addEventListener("click", (e) => {
      e.stopPropagation();
      openGroceryListModal(list);
    });

    c.querySelector('[data-act="del"]').addEventListener("click", (e) => {
      e.stopPropagation();
      if (!confirm("Delete this grocery list?")) return;
      deleteGroceryListById(list.id);
      refreshStatsAndDatalist();
      renderActivePanel();
    });

    cards.appendChild(c);
  });

  elPanel.appendChild(cards);
}

function openGroceryListModal(existing){
  const isEdit = !!existing;
  const model = existing ? deepClone(existing) : {
    id: cryptoId(),
    createdAt: Date.now(),
    updatedAt: null,
    items: []
  };

  // Auto-populate NEW lists with all Like=YES + Willing To Try=YES from My Foods
  if (!isEdit){
    model.items = buildDefaultGroceryItemsFromPrefs();
  }

  openModal({
    title: isEdit ? "Edit Grocery List" : "New Grocery List",
    body: () => {
      const box = document.createElement("div");

      const topRow = document.createElement("div");
      topRow.className = "panelTop";
      topRow.innerHTML = `
        <div class="panelTitle">
          New lists auto-fill from My Foods (Like + Willing To Try). Item names are colored (Like=green, Try=orange).
          If a My Foods note exists, a <b>*</b> appears and notes are copied into the Notes field.
        </div>
        <div class="actions">
          <button class="btn ghost" type="button" id="btnAddGItem">+ New Item</button>
        </div>
      `;

      const itemsWrap = document.createElement("div");
      itemsWrap.className = "listItems";
      itemsWrap.id = "gItemsWrap";

      box.appendChild(topRow);
      box.appendChild(itemsWrap);

      setTimeout(() => {
        const btn = box.querySelector("#btnAddGItem");
        btn.addEventListener("click", () => {
          model.items.push(blankGroceryItem());
          renderGroceryItemEditor();
        });

        // If somehow empty, keep at least 1 row
        if (!model.items.length) model.items.push(blankGroceryItem());

        renderGroceryItemEditor();
      }, 0);

      function renderGroceryItemEditor(){
        const wrap = box.querySelector("#gItemsWrap");
        wrap.innerHTML = "";

        model.items.forEach((it, idx) => {
          const row = document.createElement("div");
          row.className = "listRow";

          row.innerHTML = `
            <div class="field" data-area="item">
              <label>
                Item
                <button class="noteStarBtn" type="button" data-act="note" data-i="${idx}" style="display:none" title="Check notes" aria-label="Check notes">*</button>
              </label>
              <input type="text" data-k="name" data-i="${idx}" list="foodsDatalist" placeholder="e.g., Milk" value="${escapeAttr(it.name)}" />
            </div>

            <div class="field" data-area="qty">
              <label>Qty</label>
              <input
                type="text"
                inputmode="decimal"
                data-k="qty"
                data-i="${idx}"
                placeholder="e.g., 1.25"
                value="${escapeAttr(it.qty)}"
              />
              <div class="hint">Quarter steps only (1, 1.25, 1.5, 1.75, ...)</div>
            </div>

            <div class="field" data-area="unit">
              <label>Unit</label>
              <select data-k="unit" data-i="${idx}">
                ${unitOptions(it.unit)}
              </select>
            </div>

            <div class="field" data-area="notes">
              <label>Notes</label>
              <textarea data-k="notes" data-i="${idx}" placeholder="Optional...">${escapeHtml(it.notes||"")}</textarea>
            </div>

            <div class="field" data-area="desc">
              <label>Description</label>
              <textarea data-k="description" data-i="${idx}" placeholder="Optional...">${escapeHtml(it.description||"")}</textarea>
            </div>
          `;

          const actions = document.createElement("div");
          actions.className = "listRowActions";
          actions.style.gridColumn = "1 / -1";
          actions.innerHTML = `
            <button class="btn ghost" type="button" data-act="dup" data-i="${idx}">Duplicate</button>
            <button class="btn danger" type="button" data-act="del" data-i="${idx}">Remove</button>
          `;
          row.appendChild(actions);

          wrap.appendChild(row);
        });

        // Apply pref coloring + asterisk state per row
        wrap.querySelectorAll('.listRow').forEach((rowEl) => {
          const nameInp = rowEl.querySelector('input[data-k="name"]');
          const idx = +nameInp.dataset.i;

          const cls = prefClassForFoodName(nameInp.value);
          nameInp.classList.remove("gNameLike", "gNameTry");
          if (cls) nameInp.classList.add(cls);

          const starBtn = rowEl.querySelector('button[data-act="note"]');
          const showStar = hasFoodNote(nameInp.value);
          starBtn.style.display = showStar ? "inline-flex" : "none";

          // pressed -> small guidance (non-destructive)
          starBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            alert("Check notes (already copied into the Notes field).");
          };
        });

        // wire input/change events
        wrap.querySelectorAll("input, textarea, select").forEach(inp => {
          const k = inp.dataset.k;
          const i = +inp.dataset.i;

          inp.addEventListener("input", () => {
            if (!model.items[i]) return;

            if (k === "qty"){
              // sanitize live typing (digits + one dot)
              const clean = sanitizeQtyInput(inp.value);
              if (inp.value !== clean) inp.value = clean;
              model.items[i].qty = inp.value;
              return;
            }

            let val = (inp.value ?? "");
if (k === "unit" && val === "Each") val = "count"; // safety if any old UI ever produced this
model.items[i][k] = val;

            // If item name changes, update color + star, and auto-fill notes only if notes empty
            if (k === "name"){
              const rowEl = inp.closest(".listRow");
              if (rowEl){
                inp.classList.remove("gNameLike", "gNameTry");
                const cls = prefClassForFoodName(inp.value);
                if (cls) inp.classList.add(cls);

                const starBtn = rowEl.querySelector('button[data-act="note"]');
                const showStar = hasFoodNote(inp.value);
                if (starBtn) starBtn.style.display = showStar ? "inline-flex" : "none";

                const note = foodNoteText(inp.value);
                const notesTa = rowEl.querySelector('textarea[data-k="notes"]');
                const curNotes = (model.items[i].notes || "").trim();
                if (note && !curNotes){
                  model.items[i].notes = note;
                  if (notesTa) notesTa.value = note;
                }
              }
            }
          });

          inp.addEventListener("change", () => {
            if (!model.items[i]) return;

            if (k === "qty"){
              // snap on commit to nearest quarter
              const snapped = snapToQuarterString(inp.value);
              inp.value = snapped;
              model.items[i].qty = snapped;
              return;
            }

            let val = (inp.value ?? "");
if (k === "unit" && val === "Each") val = "count"; // safety if any old UI ever produced this
model.items[i][k] = val;

                        if (k === "name"){
              const rowEl = inp.closest(".listRow");
              if (rowEl){
                inp.classList.remove("gNameLike", "gNameTry");
                const cls = prefClassForFoodName(inp.value);
                if (cls) inp.classList.add(cls);

                const starBtn = rowEl.querySelector('button[data-act="note"]');
                const showStar = hasFoodNote(inp.value);
                if (starBtn) starBtn.style.display = showStar ? "inline-flex" : "none";

                const note = foodNoteText(inp.value);
                const notesTa = rowEl.querySelector('textarea[data-k="notes"]');
                const curNotes = (model.items[i].notes || "").trim();
                if (note && !curNotes){
                  model.items[i].notes = note;
                  if (notesTa) notesTa.value = note;
                }
              }
            }
          });

          // blur commit for qty too (mobile often doesn't fire change)
          if (k === "qty"){
            inp.addEventListener("blur", () => {
              if (!model.items[i]) return;
              const snapped = snapToQuarterString(inp.value);
              inp.value = snapped;
              model.items[i].qty = snapped;
            });
          }
        });

        // actions
        wrap.querySelectorAll("button[data-act]").forEach(b => {
          b.addEventListener("click", (e) => {
            const act = b.dataset.act;
            if (act === "note") return; // handled above
            e.preventDefault();

            const i = +b.dataset.i;
            if (act === "del"){
              model.items.splice(i, 1);
              if (!model.items.length) model.items.push(blankGroceryItem());
              renderGroceryItemEditor();
            }
            if (act === "dup"){
              model.items.splice(i+1, 0, deepClone(model.items[i]));
              renderGroceryItemEditor();
            }
          });
        });
      }

      return box;
    },
    footer: ({ close }) => {
      const btnBack = mkBtn("Go Back", "ghost", () => close());

      const btnSave = mkBtn("Save", "primary", () => {
        (model.items || []).forEach(it => {
          if (it.unit === "Each") it.unit = "count";
        });
        // filter out completely blank rows
        model.items = (model.items || []).filter(it => {
          const hasName = (it.name || "").trim().length > 0;
          const hasQty = (it.qty || "").toString().trim().length > 0;
          const hasUnit = (it.unit || "").trim().length > 0;
          const hasNotes = (it.notes || "").trim().length > 0;
          const hasDesc = (it.description || "").trim().length > 0;
          return hasName || hasQty || hasUnit || hasNotes || hasDesc;
        });

        if (isEdit){
          model.updatedAt = Date.now();
          updateGroceryList(model);
        } else {
          addGroceryList(model);
        }

        close();
        refreshStatsAndDatalist();
        renderActivePanel();
      });

      return [btnBack, btnSave];
    }
  });
}


function openGroceryViewerModal(id){
  const list = state.groceryLists.find(x => x.id === id);
  if (!list) return;

  const dt = new Date(list.updatedAt || list.createdAt);

  openModal({
    title: "Grocery List",
    body: () => {
      const box = document.createElement("div");
      box.innerHTML = `
        <div class="row" style="justify-content:space-between;gap:10px;margin-bottom:10px;">
          <div class="chip">${fmtDateTime(dt)}</div>
          <div class="chip">Items: ${list.items?.length || 0}</div>
        </div>
<div class="subCard" style="padding:12px;" id="glViewerWrap"></div>
      `;
      return box;
    },
    footer: ({ close }) => {
      const btnClose = mkBtn("Close", "ghost", () => close());

      const btnEdit  = mkBtn("Edit", "primary", () => {
        close();
        openGroceryListModal(list);
      });

      const btnDelete = mkBtn("Delete", "danger", () => {
        if (!confirm("Delete this grocery list?")) return;
        deleteGroceryListById(list.id);
        close();
        refreshStatsAndDatalist();
        renderActivePanel();
      });

      return [btnClose, btnEdit, btnDelete];
    }
  });
  setTimeout(() => {
  const wrap = document.getElementById("glViewerWrap");
  if (!wrap) return;

  const target = state.groceryLists.find(x => x.id === id);
  if (!target){
    wrap.innerHTML = `<div class="muted">List not found.</div>`;
    return;
  }

  const items = Array.isArray(target.items) ? target.items : [];
  if (!items.length){
    wrap.innerHTML = `<div class="muted">No items.</div>`;
    return;
  }

  wrap.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:10px;">
      ${items.map((it, idx) => {
        const name = escapeHtml(it.name || "");
        const qty = escapeHtml((it.qty ?? "").toString().trim());
        const unit = escapeHtml((it.unit || "").trim());
        const qtyUnit = [qty, unit].filter(Boolean).join(" ") || "‚Äî";
        const doneCls = it.done ? "glDone" : "";
        return `
          <div class="subCard" data-i="${idx}" style="padding:12px;cursor:pointer;touch-action:manipulation;">
            <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;">
              <div class="${doneCls}" data-name style="font-weight:900;">
                ${idx + 1}. ${name || "<span class='muted'>(Unnamed)</span>"}
              </div>
              <div class="chip">${qtyUnit}</div>
            </div>
          </div>
        `;
      }).join("")}
      <div class="hint">Tap an item to toggle done (strike-through).</div>
    </div>
  `;

  wrap.querySelectorAll('[data-i]').forEach(card => {
    card.addEventListener("click", () => {
      const i = +card.dataset.i;
      const cur = state.groceryLists.find(x => x.id === id);
      if (!cur || !Array.isArray(cur.items) || !cur.items[i]) return;

      cur.items[i].done = !cur.items[i].done;
      persist();

      const nameEl = card.querySelector('[data-name]');
      if (nameEl) nameEl.classList.toggle("glDone", !!cur.items[i].done);
    });
  });
}, 0);

}

    function addGroceryList(list){
      state.groceryLists.push(list);
      persist();
    }
    function updateGroceryList(list){
      const idx = state.groceryLists.findIndex(x => x.id === list.id);
      if (idx >= 0) state.groceryLists[idx] = list;
      persist();
    }

    function deleteGroceryListById(id){
  const idx = state.groceryLists.findIndex(x => x.id === id);
  if (idx >= 0){
    state.groceryLists.splice(idx, 1);
    persist();
  }
}

    function groceryPreviewHtml(list){
  const items = (list.items || []).slice(0, 6);
  if (items.length === 0) return `<div class="muted">No items.</div>`;

  return `
    <div style="display:flex;flex-direction:column;gap:6px;">
      ${items.map(it => {
        const nameHtml = groceryNameHtml(it.name || "");
        const qty = (it.qty ?? "").toString().trim();
        const unit = (it.unit || "").trim();
        const meta = [qty, unit].filter(Boolean).join(" ");
        return `<div>‚Ä¢ ${nameHtml}${meta ? ` <span class="muted">(${escapeHtml(meta)})</span>` : ""}</div>`;
      }).join("")}
      ${(list.items||[]).length > items.length ? `<div class="muted">‚Ä¶and more</div>` : ""}
    </div>
  `;
}


function renderGroceryItemsReadonly(list){
  const items = list.items || [];
  if (items.length === 0) return `<div class="muted">No items.</div>`;

  return `
    <div style="display:flex;flex-direction:column;gap:10px;">
      ${items.map((it, idx) => {
        const nameHtml = groceryNameHtml(it.name || "");
        const qty = escapeHtml((it.qty ?? "").toString());
        const unit = escapeHtml(it.unit || "");
        const notes = escapeHtml(it.notes || "");
        const desc = escapeHtml(it.description || "");

        const qtyUnit = [qty, unit].filter(Boolean).join(" ") || "‚Äî";

        return `
          <div class="subCard" style="padding:12px;">
            <div style="display:flex;justify-content:space-between;gap:10px;align-items:flex-start;">
              <div style="font-weight:800;">${idx + 1}. ${nameHtml}</div>
              <div class="chip">${qtyUnit}</div>
            </div>

            <div style="margin-top:8px;">
              ${notes
                ? `<div style="color:rgba(234,240,255,0.9);"><span class="muted">Notes:</span> ${notes}</div>`
                : `<div class="muted">No notes.</div>`
              }
            </div>

            <div style="margin-top:8px;">
              ${desc
                ? `<div style="color:rgba(234,240,255,0.9);"><span class="muted">Description:</span> ${desc}</div>`
                : `<div class="muted">No description.</div>`
              }
            </div>
          </div>
        `;
      }).join("")}
    </div>
  `;
}

function blankGroceryItem(){
  return { name:"", qty:"", unit:"", notes:"", description:"", done:false };
}

    
function unitOptions(selected){
  // Accept legacy "Each" if you already saved some that way, but normalize to "count"
  const norm = (selected === "Each") ? "count" : (selected || "");

  // Put "count" first, but label it as "Each". Keep other values unchanged.
  const units = ["", "count", "lbs", "oz", "cups", "bottles", "containers", "packages", "bags", "boxes"];

  return units.map(v => {
    const label = !v ? "‚Äî" : (v === "count" ? "Each" : v);
    return `<option value="${escapeAttr(v)}" ${v === norm ? "selected" : ""}>${label}</option>`;
  }).join("");
}


    // ---------- Modal Helpers ----------
    function openModal({ title, body, footer }){
      modalTitle.textContent = title;
      modalBody.innerHTML = "";
      modalFoot.innerHTML = "";

      const close = () => closeModal();

      const bodyNode = body?.();
      if (bodyNode) modalBody.appendChild(bodyNode);

      const footNodes = footer?.({ close }) || [];
      footNodes.forEach(n => modalFoot.appendChild(n));

      modalOverlay.classList.add("show");
      modalOverlay.setAttribute("aria-hidden", "false");

      // focus first input if present
      setTimeout(() => {
        const first = modalBody.querySelector("input, textarea, select, button");
        if (first) first.focus();
      }, 0);
    }

    function closeModal(){
      modalOverlay.classList.remove("show");
      modalOverlay.setAttribute("aria-hidden", "true");
      modalBody.innerHTML = "";
      modalFoot.innerHTML = "";
    }

    function mkBtn(text, cls, onClick){
      const b = document.createElement("button");
      b.className = "btn " + (cls || "");
      b.type = "button";
      b.textContent = text;
      b.addEventListener("click", onClick);
      return b;
    }

    function panelTopRow(desc, buttons){
      const top = document.createElement("div");
      top.className = "panelTop";

      const left = document.createElement("div");
      left.className = "panelTitle";
      left.textContent = desc;

      const right = document.createElement("div");
      right.className = "actions";

      (buttons || []).forEach(btn => {
        const b = document.createElement("button");
        b.className = "btn " + (btn.cls || "ghost");
        b.type = "button";
        b.textContent = btn.label;
        b.addEventListener("click", btn.onClick);
        right.appendChild(b);
      });

      top.appendChild(left);
      top.appendChild(right);
      return top;
    }

    // ---------- Autofill ----------
    function refreshFoodsDatalist(){
      const dl = document.getElementById("foodsDatalist");
      dl.innerHTML = "";
      const foods = getFoodsSorted();
      foods.forEach(f => {
        const opt = document.createElement("option");
        opt.value = f.name;
        dl.appendChild(opt);
      });
    }

    // For a textarea where user enters "one item per line", we provide a lightweight helper:
    // When user presses Tab, attempt to autocomplete current line from datalist-like matching.
    function attachDatalistToTextareaLines(textarea){
      if (!textarea) return;

      textarea.addEventListener("keydown", (e) => {
        if (e.key !== "Tab") return;

        const foods = getFoodsSorted().map(x => x.name);
        if (!foods.length) return;

        const { value, selectionStart } = textarea;
        const before = value.slice(0, selectionStart);
        const after = value.slice(selectionStart);

        const lineStart = before.lastIndexOf("\n") + 1;
        const line = before.slice(lineStart);
        const typed = line.trim();

        if (!typed) return;

        const match = foods.find(n => n.toLowerCase().startsWith(typed.toLowerCase()));
        if (!match) return;

        e.preventDefault();

        const newBefore = before.slice(0, lineStart) + match;
        textarea.value = newBefore + after;

        const newPos = newBefore.length;
        textarea.setSelectionRange(newPos, newPos);
      });
    }

    function formatIngredientsForViewer(items){
  const list = Array.isArray(items) ? items : [];
  if (!list.length) return "";
  return list.map(it => {
    const name = (it.name||"").trim();
    if (!name) return null;
    const qty = (it.qty||"").toString().trim();
    const unit = (it.unit||"").trim();
    const meta = [qty, unit].filter(Boolean).join(" ");
    const note = (it.notes||"").trim();
    const g = it.addToGroceries ? " [Add to Groceries]" : "";
    return `‚Ä¢ ${name}${meta ? ` (${meta})` : ""}${note ? ` ‚Äî ${note}` : ""}${g}`;
  }).filter(Boolean).join("\n");
}

function formatStepsForViewer(steps){
  const list = Array.isArray(steps) ? steps : [];
  return list.map(s => `‚Ä¢ ${(s||"").trim()}`).filter(s => s !== "‚Ä¢").join("\n");
}


    // ---------- Stats + Persistence ----------
    function refreshStatsAndDatalist(){
      statFoods.textContent = "Foods: " + state.foods.length;

      const recipeCount =
        (state.recipes.breakfast?.length || 0) +
        (state.recipes.lunch?.length || 0) +
        (state.recipes.dinner?.length || 0) +
        (state.recipes.snacks?.length || 0);

      statRecipes.textContent = "Recipes: " + recipeCount;
      statLists.textContent = "Grocery Lists: " + state.groceryLists.length;

      refreshFoodsDatalist();
    }

    function persist(){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e){
        console.warn("Persist failed:", e);
      }
    }

function openImportOptionsModal(){
  if (!pendingImportPayload) return;

  openModal({
    title: "Import JSON",
    body: () => {
      const box = document.createElement("div");
      box.innerHTML = `
        <div class="field">
          <label>Import Options</label>
          <div class="hint">Select which sections to import. Import Selected will overwrite those sections only.</div>
        </div>

        <div class="subCard" style="padding:12px;">
          ${impOpt("impWhole","Whole Profile", true)}
          <div class="hr"></div>
          ${impOpt("impFoods","My Foods")}
          ${impOpt("impBreakfast","Breakfast")}
          ${impOpt("impLunch","Lunch")}
          ${impOpt("impDinner","Dinner")}
          ${impOpt("impSnacks","Snacks")}
          ${impOpt("impGroceries","Groceries")}
        </div>
      `;
      return box;
    },
    footer: ({ close }) => {
      const btnClose = mkBtn("Close", "ghost", () => {
        pendingImportPayload = null;
        close();
      });

      const btnImport = mkBtn("Import Selected", "primary", () => {
        const whole = document.getElementById("impWhole")?.checked;

        const opts = {
          whole,
          foods: document.getElementById("impFoods")?.checked,
          breakfast: document.getElementById("impBreakfast")?.checked,
          lunch: document.getElementById("impLunch")?.checked,
          dinner: document.getElementById("impDinner")?.checked,
          snacks: document.getElementById("impSnacks")?.checked,
          groceries: document.getElementById("impGroceries")?.checked,
        };

        importSelectedSections(pendingImportPayload, opts);

        pendingImportPayload = null;
        close();

        refreshStatsAndDatalist();
        renderTabs();
        renderActivePanel();
        alert("Import complete.");
      });

      return [btnClose, btnImport];
    }
  });
}

function impOpt(id, label, checked=false){
  return `
    <div class="inline" style="justify-content:space-between;">
      <div style="font-weight:800;">${escapeHtml(label)}</div>
      <label class="chk">
        <input type="checkbox" id="${id}" ${checked ? "checked" : ""} />
        <span>Yes</span>
      </label>
    </div>
  `;
}

function importSelectedSections(payload, opts){
  // unwrap payload if you used {schema, data}
  const incomingRaw = (payload && payload.data) ? payload.data : payload;
  const incoming = normalizeState(incomingRaw);

  if (opts.whole){
    state.ui = incoming.ui;
    state.foods = incoming.foods;
    state.recipes = incoming.recipes;
    state.groceryLists = incoming.groceryLists;
    persist();
    activeTab = state.ui?.activeTab || "myFoods";
    return;
  }

  // Selective overwrite only
  if (opts.foods) state.foods = incoming.foods;

  state.recipes = state.recipes || { breakfast:[], lunch:[], dinner:[], snacks:[] };

  if (opts.breakfast) state.recipes.breakfast = incoming.recipes.breakfast;
  if (opts.lunch) state.recipes.lunch = incoming.recipes.lunch;
  if (opts.dinner) state.recipes.dinner = incoming.recipes.dinner;
  if (opts.snacks) state.recipes.snacks = incoming.recipes.snacks;

  if (opts.groceries) state.groceryLists = incoming.groceryLists;

  persist();
}
    
    function exportStateToJson(){
  // Always export normalized data to keep format stable
  const exportObj = {
    schema: "feedme_backup_v1",
    exportedAt: new Date().toISOString(),
    data: normalizeState(deepClone(state))
  };

  const json = JSON.stringify(exportObj, null, 2);
  const blob = new Blob([json], { type: "application/json" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = `feedme_backup_${new Date().toISOString().replaceAll(":","-")}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();

  setTimeout(() => URL.revokeObjectURL(url), 1000);
}

    function importStateFromJson(payload){
  // Supports either full wrapper {schema, data} or direct state object
  let incoming = payload;

  if (payload && typeof payload === "object" && payload.data){
    incoming = payload.data;
  }

  // Validate shape by normalizing (drops unknown structure safely)
  const normalized = normalizeState(incoming);

  const totalFoods = normalized.foods.length;
  const totalRecipes =
    (normalized.recipes.breakfast?.length || 0) +
    (normalized.recipes.lunch?.length || 0) +
    (normalized.recipes.dinner?.length || 0) +
    (normalized.recipes.snacks?.length || 0);
  const totalLists = normalized.groceryLists.length;

  const msg =
    `Import this backup?\n\n` +
    `Foods: ${totalFoods}\n` +
    `Recipes: ${totalRecipes}\n` +
    `Grocery Lists: ${totalLists}\n\n` +
    `This will REPLACE your current local data on this device/browser.`;

  if (!confirm(msg)) return;

  // Replace in-memory state fields (preserve object reference)
  state.ui = normalized.ui;
  state.foods = normalized.foods;
  state.recipes = normalized.recipes;
  state.groceryLists = normalized.groceryLists;

  persist();

  // Make UI reflect imported tab/contents immediately
  activeTab = state.ui?.activeTab || "myFoods";
  renderTabs();
  renderActivePanel();
  refreshStatsAndDatalist();

  alert("Import complete.");
}

    function loadState(){
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw){
        try{
          const parsed = JSON.parse(raw);
          return normalizeState(parsed);
        } catch {}
      }
      return normalizeState({});
    }

    function normalizeState(s){
      return {
        ui: {
              activeTab: s.ui?.activeTab || "myFoods",
              foodSearch: (typeof s.ui?.foodSearch === "string") ? s.ui.foodSearch : "",
              foodFilter: s.ui?.foodFilter || "like_try",
            },
        foods: Array.isArray(s.foods) ? s.foods : [],
        recipes: {
          breakfast: Array.isArray(s.recipes?.breakfast) ? s.recipes.breakfast : [],
          lunch: Array.isArray(s.recipes?.lunch) ? s.recipes.lunch : [],
          dinner: Array.isArray(s.recipes?.dinner) ? s.recipes.dinner : [],
          snacks: Array.isArray(s.recipes?.snacks) ? s.recipes.snacks : [],
        },
        groceryLists: Array.isArray(s.groceryLists) ? s.groceryLists : [],
      };
    }

    // ---------- Utilities ----------
    function cryptoId(){
      if (crypto?.randomUUID) return crypto.randomUUID();
      return "id_" + Math.random().toString(16).slice(2) + "_" + Date.now();
    }

    function fmtDateTime(d){
      // user-friendly, device locale
      try{
        return d.toLocaleString(undefined, { year:"numeric", month:"short", day:"2-digit", hour:"numeric", minute:"2-digit" });
      } catch {
        return d.toString();
      }
    }

    function deepClone(obj){
      return JSON.parse(JSON.stringify(obj));
    }

    function snippetLines(text, maxLines){
      const lines = String(text || "").split(/\r?\n/).filter(Boolean);
      return lines.slice(0, maxLines).join("\n") + (lines.length > maxLines ? "\n‚Ä¶" : "");
    }

    function viewerField(label, value){
      const v = (value || "").trim();
      return `
        <div style="display:flex;justify-content:space-between;gap:12px;align-items:flex-start;">
          <div class="muted">${escapeHtml(label)}:</div>
          <div style="font-weight:800;">${v ? escapeHtml(v) : "‚Äî"}</div>
        </div>
      `;
    }

    function viewerBlock(label, value){
      const v = (value || "").trim();
      return `
        <div style="margin-top:12px;">
          <div class="muted" style="margin-bottom:6px;">${escapeHtml(label)}:</div>
          <div style="white-space:pre-wrap;line-height:1.45;">${v ? escapeHtml(v) : "‚Äî"}</div>
        </div>
      `;
    }

    function escapeHtml(str){
      return String(str ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }
    function escapeAttr(str){
      return escapeHtml(str).replaceAll("\n"," ");
    }

  </script>
</body>
</html>
